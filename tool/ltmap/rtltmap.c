/*===========================================================================*
 *-                                                                         -*
 *-  Module  :   rtltmap.c                                                  -*
 *-                                                                         -*
 *-  Purpose :   RtLtMap toolkit                                            -*
 *-                                                                         -*
 *===========================================================================*/

/*===========================================================================*
 *--- Include files ---------------------------------------------------------*
 *===========================================================================*/

/* Needed for memset */
#include "string.h"

#include "rwcore.h"
#include "rpworld.h"
#include "rprandom.h"

#include "rpcollis.h"
#include "rtbary.h"

#include "rpplugin.h"
#include "rpdbgerr.h"

#include "rppvs.h"
/* We need to use the non-INCGEN-d version of rpltmap.h */
#include "../../plugin/ltmap/rpltmap.h"
#include "rtltmap.h"

#include "polypack.h"
#include "ltmapvar.h"

/* In the RtLtMap[Something]CalculateDensity () functions, the total surface
 * area of the object in question is mapped onto the lightmap pixels as if
 * they would match up exactly.  They don't, for two reasons:
 *   1) There's padding around PolySets in the lightmaps, wasting pixels
 *   2) Not all tris will be mapped 'square on' to the camera, saving pixels
 * This fudge factor shrinks the density slightly to err on the side of
 * getting all the object onto a single light map, rather than accidently
 * spilling a few polysets onto a new, completely empty, lightmap */
#define DENSITY_FUDGE_FACTOR 0.68f;

#ifdef SHOWLIGHTMAPUSAGE
#   include "image.h"
#endif

/**
 * \ingroup rtltmap
 * \page rtltmapoverview RtLtMap Toolkit Overview
 *
 * \par Requirements
 * \li \b Headers: rwcore.h, rpworld.h, rprandom.h, rpltmap.h, rtltmap.h
 * \li \b Libraries: rwcore, rpworld, rpcollis, rprandom, rpltmap, rppvs, rtbary, rtintsec, rtltmap
 * \li \b Plugin \b attachments: \ref RpWorldPluginAttach, \ref RpCollisionPluginAttach,
 *     \ref RpRandomPluginAttach, \ref RpLtMapPluginAttach, \ref RpPVSPluginAttach
 *
 * \subsection ltmaptoolkitoverview Overview
 *
 * The \ref rtltmap toolkit contains a suite of functionality for
 * generating lightmaps. The process of lightmap generation consists
 * of two main stages. Firstly, lightmaps need to be allocated and
 * associated with objects, and the UV coordinates for the lightmap
 * pass need to be calculated (see \ref RtLtMapLightMapsCreate).
 * Secondly, color values need to be calculated for lightmap texels
 * and, optionally, vertex prelight colors (see \ref RtLtMapIlluminate).
 *
 * Lightmaps generated by this toolkit support tristripped geometry
 * (unusual for lightmap implementations) and so will render very quickly,
 * especially on such platforms as PlayStation 2. A few visual artifacts remain due
 * to this tristrip support, though they will, in the vast majority of cases,
 * go unnoticed or easily be worked around.
 *
 * Lighting calculations support the standard \ref RpLight types, as well as
 * area light sources, specified with normal geometry on a per-material basis
 * (\ref RtLtMapAreaLightGroupCreate). Area lighting can produce very
 * convincing lighting solutions, with subtle gradients and soft shadows.
 */


/*===========================================================================*
 *--- Local Global Variables ------------------------------------------------*
 *===========================================================================*/
#if (defined(RWDEBUG))
long _rtLtMapStackDepth = 0;
#endif /* (defined(RWDEBUG)) */

/*===========================================================================*
 *--- Local defines ---------------------------------------------------------*
 *===========================================================================*/


/*===========================================================================*
 *--- Local types -----------------------------------------------------------*
 *===========================================================================*/
typedef struct _rtdensityCalculateData _rtdensityCalculateData;

struct _rtdensityCalculateData
{
    RwReal area;
    RwInt32 numWS;
};

/*===========================================================================*
 *--- Local variables -------------------------------------------------------*
 *===========================================================================*/


/*===========================================================================*
 *--- Global Variables ------------------------------------------------------*
 *===========================================================================*/

rtLtMapGlobalVars rtLtMapGlobals = {

    {{ 0.0f, 0.0f, 1.0f},
     { 1.0f, 0.0f, 0.0f},
     { 0.0f, 1.0f, 0.0f},
     { 0.0f, 0.0f, 1.0f},
     { 1.0f, 0.0f, 0.0f},
     { 0.0f, 1.0f, 0.0f}},  /* right vector */

    {{ 0.0f, 1.0f, 0.0f},
     { 0.0f, 0.0f, 1.0f},
     { 1.0f, 0.0f, 0.0f},
     { 0.0f, 1.0f, 0.0f},
     { 0.0f, 0.0f, 1.0f},
     { 1.0f, 0.0f, 0.0f}},  /* up vector */

    { 0.0f, 0.0f, 0.0f },   /* sort vector */

    NULL,                   /* ltMapSlots */

    0,      /* skyFlags */
    NULL,   /* visibility callback */
    0.95f,  /* vis collision scalar */

    NULL,               /* current lighting world */
    NULL,               /* current area light group */
    rpLIGHTLIGHTWORLD,  /* light object flag */

    0.0f,               /* area light density */

    NULL,                           /* ltMap post process callback */
    RtLtMapSkyLumCalcSigmaCallBack, /* sky lum callback */

    {{{0, 0, 0}, {0, 0, 0}, 0, {NULL, NULL, NULL}}, 0, FALSE},

#if (defined(SHOWLIGHTMAPUSAGE))
    (RwImage *)NULL /* ltMap usage image name */
#endif /* (defined(SHOWLIGHTMAPUSAGE)) */

};

/*===========================================================================*
 *--- Local functions -------------------------------------------------------*
 *===========================================================================*/

/****************************************************************************
 LtMapWorldSectorGatherAtomics
 */
static RpAtomic *
LtMapWorldSectorGatherAtomics(RpAtomic *atomic, void *data)
{
    LtMapSessionInfo *sessionInfo = (LtMapSessionInfo *)data;
    RwBool    found = FALSE;
    RwInt32   i;

    RWFUNCTION(RWSTRING("LtMapWorldSectorGatherAtomics"));

    /* Given that atomics can overlap multiple worldsectors,
     * ensure that we don't add any atomic more than once: */
    if (RWSRCGLOBAL(renderFrame) == atomic->renderFrame)
    {
        RWRETURN(atomic);
    }
    atomic->renderFrame = RWSRCGLOBAL(renderFrame);

    if (NULL != sessionInfo->session->atomicList)
    {
        /* Only add items in the pre-provided list */
        for (i = 0;i < sessionInfo->session->numAtomics;i++)
        {
            if (atomic == sessionInfo->session->atomicList[i])
            {
                found = TRUE;
                break;
            }
        }
        if (FALSE == found)
            RWRETURN(atomic);
    }

    if ((FALSE != sessionInfo->useCamera) && (NULL != sessionInfo->session->camera) )
    {
        /* Frustum-test the object */
        if (rwSPHEREOUTSIDE == RwCameraFrustumTestSphere(
                sessionInfo->session->camera, RpAtomicGetWorldBoundingSphere(atomic)) )
        {
            RWRETURN(atomic);
        }
    }

    RWASSERT(NULL != sessionInfo->localAtomics);
   *(RpAtomic **)rwSListGetNewEntry(sessionInfo->localAtomics,
       rwID_LTMAPPLUGIN | rwMEMHINTDUR_EVENT) = atomic;

    RWRETURN(atomic);
}

/****************************************************************************
 LtMapWorldSectorGather
 */
static RpWorldSector *
LtMapWorldSectorGather(RpWorldSector *sector, void *data)
{
    LtMapSessionInfo *sessionInfo = (LtMapSessionInfo *)data;
    RwBool    found = FALSE;
    RwInt32   i;

    RWFUNCTION(RWSTRING("LtMapWorldSectorGather"));

    /* Add all contained atomics into the list */
    if (-1 != sessionInfo->session->numAtomics)
    {
        RpWorldSectorForAllAtomics(sector, LtMapWorldSectorGatherAtomics, data);
    }

    if (-1 == sessionInfo->session->numSectors)
    {
        RWRETURN(sector);
    }

    if (NULL != sessionInfo->session->sectorList)
    {
        /* Only add items in the pre-provided list */
        for (i = 0;i < sessionInfo->session->numSectors;i++)
        {
            if (sector == sessionInfo->session->sectorList[i])
            {
                found = TRUE;
                break;
            }
        }
        if (FALSE == found)
            RWRETURN(sector);
    }
    RWASSERT(NULL != sessionInfo->localSectors);
   *(RpWorldSector **)rwSListGetNewEntry(sessionInfo->localSectors,
                     rwID_LTMAPPLUGIN | rwMEMHINTDUR_EVENT) = sector;

    RWRETURN(sector);
}

/****************************************************************************
 _rtLtMapLightingSessionInfoCreate
 */
LtMapSessionInfo *
_rtLtMapLightingSessionInfoCreate(LtMapSessionInfo       *sessionInfo,
                               RtLtMapLightingSession *session,
                               RwBool                  useCamera)
{
    RwInt32 i;

    /* This function gets called by lightMapCreate/Clear/Destroy, illuminate
     * and areaLightGroupCreate - in each case, different sets of objects are
     * required, so we don't do any culling (on, e.g rpATOMICRENDER) in here
     * and the calling function just ignored certain items in the list. */

    RWFUNCTION(RWSTRING("_rtLtMapLightingSessionInfoCreate"));

    RWASSERT(NULL != sessionInfo);
    RWASSERT(NULL != session);
    sessionInfo->session   = session;
    sessionInfo->useCamera = useCamera;

    /* numAtomics/numSectors being '-1' prevents us from gathering atomics/sectors */

    _rwFrameSyncDirty();

    if (-1 == session->numSectors)
    {
        sessionInfo->localSectors = (RwSList *)NULL;
    }
    else
    {
        sessionInfo->localSectors = rwSListCreate(sizeof(RpWorldSector *),
                                  rwID_ATOMICSECT | rwMEMHINTDUR_EVENT);
        RWASSERT(NULL != sessionInfo->localSectors);
    }
    if (-1 == session->numAtomics)
    {
        sessionInfo->localAtomics = NULL;
    }
    else
    {
        sessionInfo->localAtomics = rwSListCreate(sizeof(RpAtomic *),
                              rwID_ATOMIC | rwMEMHINTDUR_EVENT);
        RWASSERT(NULL != sessionInfo->localAtomics);
    }
    /* Hey, we should be lighting *something*! :) */
    RWASSERT((-1 != session->numSectors) || (-1 != session->numAtomics));

    /* We update renderFrame to ensure that no atomic gets added to the list twice */
    RWSRCGLOBAL(renderFrame)++;
    if ((NULL != session->camera) && (FALSE != useCamera))
    {
        if (NULL != session->world)
        {
            RWASSERT(session->world == RwCameraGetWorld(session->camera));
        }
        /* Gather atomics and sectors, taking into account the camera and provided lists */
        RwCameraForAllSectorsInFrustum(session->camera, LtMapWorldSectorGather, (void *)sessionInfo);
    }
    else if ((NULL != session->sectorList) || (NULL != session->atomicList))
    {
        /* Just copy the atomics and/or sectors from the incoming lists */
        if ((-1 != session->numSectors) && (NULL != session->sectorList))
        {
            for (i = 0;i < session->numSectors;i++)
            {
               *(RpWorldSector **)rwSListGetNewEntry(sessionInfo->localSectors,
                    rwID_LTMAPPLUGIN | rwMEMHINTDUR_EVENT) = session->sectorList[i];
            }
        }
        if ((-1 != session->numAtomics) && (NULL != session->atomicList))
        {
            for (i = 0;i < session->numAtomics;i++)
            {
               *(RpAtomic **)rwSListGetNewEntry(sessionInfo->localAtomics,
                    rwID_LTMAPPLUGIN | rwMEMHINTDUR_EVENT) = session->atomicList[i];
            }
        }
    }
    else
    {
        /* Gather up all atomics and sectors in the world */
        RWASSERT (NULL != session->world);
        RpWorldForAllWorldSectors(session->world, LtMapWorldSectorGather, (void *)sessionInfo);
    }

    if (NULL != sessionInfo->localSectors)
    {
        sessionInfo->numSectors = rwSListGetNumEntries(sessionInfo->localSectors);
    }
    else
    {
        sessionInfo->numSectors = 0;
    }

    if (NULL != sessionInfo->localAtomics)
    {
        sessionInfo->numAtomics = rwSListGetNumEntries(sessionInfo->localAtomics);
    }
    else
    {
        sessionInfo->numAtomics = 0;
    }

    RWRETURN(sessionInfo);
}

/****************************************************************************
 _rtLtMapLightingSessionInfoDestroy
 */
RwBool
_rtLtMapLightingSessionInfoDestroy(LtMapSessionInfo *sessionInfo)
{
    RWFUNCTION(RWSTRING("_rtLtMapLightingSessionInfoDestroy"));
    RWASSERT(NULL != sessionInfo);

    if (NULL != sessionInfo->localAtomics)
    {
        rwSListDestroy(sessionInfo->localAtomics);
        sessionInfo->localAtomics = (RwSList *)NULL;
    }
    sessionInfo->numAtomics = 0;

    if (NULL != sessionInfo->localSectors)
    {
        rwSListDestroy(sessionInfo->localSectors);
        sessionInfo->localSectors = (RwSList *)NULL;
    }
    sessionInfo->numSectors = 0;

    sessionInfo->session   = (RtLtMapLightingSession *)NULL;
    sessionInfo->useCamera = FALSE;

    RWRETURN(TRUE);
}

/****************************************************************************
 _rtLtMapNameGen
 */
RwChar *
_rtLtMapNameGen(RwChar *result, RwBool addExt)
{
    RwChar   numberString[11];
    RwUInt32 number, prefixLength, numberLength, i, maxCount = 1;

    RWFUNCTION(RWSTRING("_rtLtMapNameGen"));
    RWASSERT(NULL != result);

    /* Work out the max. allowable value given the current prefix string */
    prefixLength = rwstrlen(_rpLtMapGlobals.prefix);
    numberLength = 8 - prefixLength;
    RWASSERT(numberLength > 0);
    for (i = 0;i < numberLength;i++)
        maxCount *= 10;
    number = _rpLtMapGlobals.lightMapCount++;
    if (number >= maxCount)
    {
        _rpLtMapGlobals.lightMapCount = 0;
        number = 0;
        RwDebugSendMessage(rwDEBUGMESSAGE, "LtMapNameGen",
            "Warning: lightmap counter number wrapped around to zero, lightmaps may get overwritten on stream write");
    }

    /* Fill the result w/ the prefix string followed by zeroes */
    RWASSERT(prefixLength <= rpLTMAPMAXPREFIXSTRINGLENGTH);
    rwstrcpy(&(result[0]), _rpLtMapGlobals.prefix);
    for (i = 0;i < numberLength;i++)
        rwstrcat(result, RWSTRING("0"));

    /* Add the number to the end of the string */
    rwsprintf(numberString, "%d", number);
    RWASSERT(rwstrlen(numberString) + prefixLength <= 8);
    rwstrcpy(&(result[8 - rwstrlen(numberString)]), numberString);

    if (FALSE != addExt)
    {
        /* Add the file extension */
        rwstrcat(result, rpLtMapImageExtension);
    }

    RWRETURN(result);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapMaterialSetLightMapDensityModifier sets the
 * lightmap density modifier of a given material.
 *
 * The lightmap density modifier multiplies the default lightmap
 * sample density used, within \ref RtLtMapLightMapsCreate, for
 * creating lightmaps. This is useful for getting large areas
 * sampled at a low frequency, thus reducing the number of required
 * lightmap texels and speeding up lighting calculations.
 *
 * This function should be called before a call to
 * \ref RtLtMapLightMapsCreate in order to have any effect.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  material  A pointer to an \ref RpMaterial
 * \param  density   An \ref RwReal specifying the new lightmap sample
 *                   density modifier for this material
 *
 * \return A pointer to the material on success, otherwise NULL
 *
 * \see RtLtMapMaterialGetLightMapDensityModifier
 * \see RtLtMapMaterialGetFlags
 * \see RtLtMapMaterialSetFlags
 * \see RtLtMapLightMapsCreate
 */
RpMaterial *
RtLtMapMaterialSetLightMapDensityModifier(RpMaterial *material, RwReal density)
{
    LtMapMaterialData *matData;

    RWAPIFUNCTION(RWSTRING("RtLtMapMaterialSetLightMapDensityModifier"));

    RWASSERT(NULL != material);
    matData = RPLTMAPMATERIALGETDATA(material);

    matData->lightMapDensity = density;

    RWRETURN(material);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapMaterialGetLightMapDensityModifier retrieves the
 * lightmap density modifier of a given material.
 *
 * The lightmap density modifier multiplies the default lightmap
 * sample density used, within \ref RtLtMapLightMapsCreate, for
 * creating lightmaps. This is useful for getting large areas
 * sampled at a low frequency, thus reducing the number of required
 * lightmap texels and speeding up lighting calculations.
 *
 * This function should be called before a call to
 * \ref RtLtMapLightMapsCreate in order to have any effect.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  material  A pointer to an \ref RpMaterial for which to get
 *                   the lightmap sample density modifier
 *
 * \return The lightmap sample density modifier of the specified material
 *
 * \see RtLtMapMaterialSetLightMapDensityModifier
 * \see RtLtMapMaterialGetFlags
 * \see RtLtMapMaterialSetFlags
 * \see RtLtMapLightMapsCreate
 */
RwReal
RtLtMapMaterialGetLightMapDensityModifier(RpMaterial *material)
{
    LtMapMaterialData *matData;

    RWAPIFUNCTION(RWSTRING("RtLtMapMaterialGetLightMapDensityModifier"));

    RWASSERT(NULL != material);
    matData = RPLTMAPMATERIALGETDATA(material);

    RWRETURN(matData->lightMapDensity);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapMaterialSetFlags sets the lightmap-related flags
 * of a given material.
 *
 * Material flags control material properties relevant to lighting
 * calculations. See \ref RtLtMapMaterialFlags for further details.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  material  A pointer to an \ref RpMaterial
 * \param  flags     An \ref RwUInt32 specifying the new flags for this material
 *
 * \return A pointer to the material on success, otherwise NULL
 *
 * \see RtLtMapMaterialGetFlags
 * \see RtLtMapMaterialSetLightMapDensityModifier
 * \see RtLtMapMaterialGetLightMapDensityModifier
 * \see RtLtMapMaterialSetAreaLightDensityModifier
 * \see RtLtMapMaterialGetAreaLightDensityModifier
 * \see RtLtMapMaterialSetAreaLightRadiusModifier
 * \see RtLtMapMaterialGetAreaLightRadiusModifier
 * \see RtLtMapMaterialSetAreaLightColor
 * \see RtLtMapMaterialGetAreaLightColor
 * \see RtLtMapAreaLightGroupCreate
 * \see RtLtMapAreaLightGroupDestroy
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapIlluminate
 */
RpMaterial *
RtLtMapMaterialSetFlags(RpMaterial *material, RwUInt32 flags)
{
    LtMapMaterialData *matData;

    RWAPIFUNCTION(RWSTRING("RtLtMapMaterialSetFlags"));

    RWASSERT(NULL != material);
    matData = RPLTMAPMATERIALGETDATA(material);

    matData->flags = flags;

    RWRETURN(material);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapMaterialGetFlags retrieves the lightmap-related flags
 * of a given material.
 *
 * Material flags control material properties relevant to lighting
 * calculations. See \ref RtLtMapMaterialFlags for further details.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  material  A pointer to an \ref RpMaterial
 *
 * \return The material's flags
 *
 * \see RtLtMapMaterialSetFlags
 * \see RtLtMapMaterialSetLightMapDensityModifier
 * \see RtLtMapMaterialGetLightMapDensityModifier
 * \see RtLtMapMaterialSetAreaLightDensityModifier
 * \see RtLtMapMaterialGetAreaLightDensityModifier
 * \see RtLtMapMaterialSetAreaLightRadiusModifier
 * \see RtLtMapMaterialGetAreaLightRadiusModifier
 * \see RtLtMapMaterialSetAreaLightColor
 * \see RtLtMapMaterialGetAreaLightColor
 * \see RtLtMapAreaLightGroupCreate
 * \see RtLtMapAreaLightGroupDestroy
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapIlluminate
 */
RwUInt32
RtLtMapMaterialGetFlags(RpMaterial *material)
{
    LtMapMaterialData *matData;

    RWAPIFUNCTION(RWSTRING("RtLtMapMaterialGetFlags"));

    RWASSERT(NULL != material);
    matData = RPLTMAPMATERIALGETDATA(material);

    RWRETURN(matData->flags);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapWorldSectorGetNumSamples returns the number of lighting samples
 * in a given world sector.
 *
 * A world sector may have both lightmap and vertex prelight samples (depending
 * on its flags - see \ref RtLtMapObjectFlags - and whether or not it has
 * had a lightmap created for it yet).
 *
 * Note that a returned value of zero does not indicate an error, merely
 * that no lighting samples were found in the supplied sector.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  sector  A pointer to a world sector
 *
 * \return The number of lightmap samples in the sector on success, otherwise '-1'.
 *
 * \see RtLtMapAtomicGetNumSamples
 * \see RtLtMapLightingSessionGetNumSamples
 * \see RtLtMapIlluminate
 */
RwInt32
RtLtMapWorldSectorGetNumSamples(RpWorldSector *sector)
{
    LtMapObjectData *objectData;
    RwInt32 numSamples;

    RWAPIFUNCTION(RWSTRING("RtLtMapWorldSectorGetNumSamples"));

    RWASSERT(NULL != sector);
    objectData = RPLTMAPWORLDSECTORGETDATA(sector);

    numSamples = objectData->numSamples;
    if (objectData->flags & rtLTMAPOBJECTVERTEXLIGHT)
    {
        /* Add on numVerts if we're doing vertex lighting */
        numSamples += sector->numVertices;
    }

    RWRETURN(numSamples);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapAtomicGetNumSamples returns the number of lighting samples
 * in a given atomic.
 *
 * An atomic may have both lightmap and vertex prelight samples (depending
 * on its flags - see \ref RtLtMapObjectFlags - and whether or not it has
 * had a lightmap created for it yet).
 *
 * Note that a returned value of zero does not indicate an error, merely
 * that no lighting samples were found in the supplied atomic.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an atomic
 *
 * \return The number of lightmap samples in the atomic on success, otherwise '-1'.
 *
 * \see RtLtMapWorldSectorGetNumSamples
 * \see RtLtMapLightingSessionGetNumSamples
 * \see RtLtMapIlluminate
 */
RwInt32
RtLtMapAtomicGetNumSamples(RpAtomic *atomic)
{
    LtMapObjectData *objectData;
    RwInt32 numSamples;

    RWAPIFUNCTION(RWSTRING("RtLtMapAtomicGetNumSamples"));

    RWASSERT(NULL != atomic);
    objectData = RPLTMAPATOMICGETDATA(atomic);

    numSamples = objectData->numSamples;
    if (objectData->flags & rtLTMAPOBJECTVERTEXLIGHT)
    {
        /* Add on numVerts if we're doing vertex lighting */
        numSamples += RpGeometryGetNumVertices(RpAtomicGetGeometry(atomic));
    }

    RWRETURN(numSamples);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapLightingSessionGetNumSamples calculates the number of lighting
 * samples represented by the objects in a specified \ref RtLtMapLightingSession.
 *
 * This function traverses the objects specified by the received
 * \ref RtLtMapLightingSession structure. Only atomics flagged as rpATOMICRENDER
 * will be used. Note that the camera member of this structure is used.
 *
 * As with \ref RtLtMapIlluminate, this function fills in the totalSamples
 * member of the received lighting session. The value calculated is the same as
 * that calculated by \ref RtLtMapIlluminate. Both lightmap samples and vertex
 * lighting samples are taken into account. Camera frustum culling is done on
 * a per-object basis, hence there may be samples for which no lighting
 * calculations are actually done within \ref RtLtMapIlluminate (these are still
 * counted in tracking lighting progress, though - see also
 * \ref RtLtMapIlluminateProgressCallBack).
 *
 * Note that a returned value of zero does not indicate an error, merely that
 * no (visible) lighting samples were found in the supplied lighting session.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtLtMapLightingSession
 *
 * \return The number of lighting samples in the session on success, otherwise '-1'.
 *
 * \see RtLtMapAtomicGetNumSamples
 * \see RtLtMapWorldSectorGetNumSamples
 * \see RtLtMapIlluminate
 */
RwInt32
RtLtMapLightingSessionGetNumSamples(RtLtMapLightingSession *session)
{
    LtMapSessionInfo sessionInfo;
    LtMapObjectData *objectData;
    RwInt32 i, startObj, numObj, endObj;

    RWAPIFUNCTION(RWSTRING("RtLtMapLightingSessionGetNumSamples"));

    /* Get local lists of sectors/atomics from the session
     * (culled w.r.t the incoming camera and object lists, if present) */
    _rtLtMapLightingSessionInfoCreate(&sessionInfo, session, TRUE);

    /* Count up how many samples in the session (-> % progress) */
    session->totalTriNVert = 0;
    session->totalSamples = 0;

    startObj = (RwInt32) session->startObj;
    numObj = 0;
    endObj = 0;

    if (startObj < (RwInt32) sessionInfo.numSectors)
    {
        if (session->numObj == 0)
        {
            endObj = sessionInfo.numSectors;
        }
        else
        {
            endObj = startObj + (RwInt32) session->numObj;

            if (endObj > (RwInt32) sessionInfo.numSectors)
                endObj = (RwInt32) sessionInfo.numSectors;
        }

        numObj = endObj - startObj;

        for (i = startObj; i < (RwInt32) endObj ;i++)
        {

            RpWorldSector *sector = *(RpWorldSector **) rwSListGetEntry(sessionInfo.localSectors, i);

            objectData = RPLTMAPWORLDSECTORGETDATA(sector);

            session->totalSamples += RtLtMapWorldSectorGetNumSamples(sector);

            session->totalTriNVert += RpWorldSectorGetNumTriangles(sector);
        }
    }

    if ((session->numObj == 0) || (numObj < (RwInt32) session->numObj))
    {
        startObj = session->startObj - sessionInfo.numSectors;
        if (startObj < 0)
            startObj = 0;

        if (session->numObj == 0)
        {
            endObj = sessionInfo.numAtomics;
        }
        else
        {
            endObj = startObj + (session->numObj - numObj);

            if (endObj > (RwInt32) sessionInfo.numAtomics)
                endObj = (RwInt32) sessionInfo.numAtomics;
        }

        numObj = endObj - startObj;

        for (i = startObj; i < (RwInt32) endObj; i++)
        {
            RpAtomic *atomic = *(RpAtomic **)rwSListGetEntry(sessionInfo.localAtomics, i);

            if (RpAtomicGetFlags(atomic) & rpATOMICRENDER)
            {
                objectData = RPLTMAPATOMICGETDATA(atomic);

                session->totalSamples += RtLtMapAtomicGetNumSamples(atomic);

                if ((objectData->flags & rtLTMAPOBJECTLIGHTMAP) ||
                    (objectData->flags & rtLTMAPOBJECTVERTEXLIGHT))
                {
                    session->totalTriNVert += RpGeometryGetNumTriangles(RpAtomicGetGeometry(atomic));
                }
            }
        }
    }

    session->totalObj = sessionInfo.numSectors + sessionInfo.numAtomics;

    _rtLtMapLightingSessionInfoDestroy(&sessionInfo);

    RWRETURN(session->totalSamples);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapGetLightMapCounter is used to retrieve the counter used
 * to name lightmaps with sequentially increasing numeric suffices.
 *
 * See \ref RtLtMapSetLightMapCounter for further details.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \return The value of the global lightmap counter
 *
 * \see RtLtMapSetLightMapCounter
 * \see RtLtMapGetDefaultPrefixString
 * \see RtLtMapSetDefaultPrefixString
 * \see RpLtMapAtomicGetLightMap
 * \see RpLtMapAtomicSetLightMap
 * \see RpLtMapWorldSectorGetLightMap
 * \see RpLtMapWorldSectorSetLightMap
 */
RwUInt32
RtLtMapGetLightMapCounter(void)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapGetLightMapCounter"));

    RWRETURN(_rpLtMapGlobals.lightMapCount);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapSetLightMapCounter is used to modify the counter used
 * to name lightmaps with sequentially increasing numeric suffices.
 *
 * When lightmaps are created (see \ref RtLtMapLightMapsCreate), their
 * name is automatically generated by appending a counter value (incremented
 * by one for each new lightmap generated) to a global 'prefix' string.
 * For example, if the current prefix string is "ltmp", the fifth lightmap
 * to be created will be named "ltmp0005" (note that the string and number
 * are padded with zeroes to be 8 characters long).
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  value  The new value of the global lightmap counter
 *
 * \return TRUE on success, FALSE otherwise
 *
 * \see RtLtMapGetLightMapCounter
 * \see RtLtMapGetDefaultPrefixString
 * \see RtLtMapSetDefaultPrefixString
 * \see RpLtMapAtomicGetLightMap
 * \see RpLtMapAtomicSetLightMap
 * \see RpLtMapWorldSectorGetLightMap
 * \see RpLtMapWorldSectorSetLightMap
 */
RwBool
RtLtMapSetLightMapCounter(RwUInt32 value)
{
    RwUInt32 length, maxCount = 1;

    RWAPIFUNCTION(RWSTRING("RtLtMapSetLightMapCounter"));

    /* Work out the max. allowable value given the current prefix string */
    length = 8 - rwstrlen(_rpLtMapGlobals.prefix);
    RWASSERT(length > 0);
    while (length--)
        maxCount *= 10;
    if (value >= maxCount)
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtLtMapSetLightMapCounter",
            "Count value too large");
        RWRETURN(FALSE);
    }

    _rpLtMapGlobals.lightMapCount = value;

    RWRETURN(TRUE);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapGetDefaultPrefixString is used to retrieve the default
 * string used to generate lightmap texture names.
 *
 * See \ref RtLtMapSetDefaultPrefixString for further details.
 *
 * \return A pointer to the current lightmap prefix string
 *
 * \see RtLtMapSetDefaultPrefixString
 * \see RtLtMapGetLightMapCounter
 * \see RtLtMapSetLightMapCounter
 * \see RpLtMapAtomicGetLightMap
 * \see RpLtMapAtomicSetLightMap
 * \see RpLtMapWorldSectorGetLightMap
 * \see RpLtMapWorldSectorSetLightMap
 */
const RwChar *
RtLtMapGetDefaultPrefixString(void)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapGetDefaultPrefixString"));

    RWRETURN(&(_rpLtMapGlobals.prefix[0]));
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapSetDefaultPrefixString is used to set the default
 * string used to generate lightmap texture names.
 *
 * When lightmaps are created (see \ref RtLtMapLightMapsCreate), their
 * name is automatically generated by appending a counter value (incremented
 * by one for each new lightmap generated) to a global 'prefix' string.
 * For example, if the current prefix string is "ltmp", the fifth lightmap
 * to be created will be named "ltmp0005" (note that the string and number
 * are padded with zeroes to be 8 characters long). Calling this function
 * resets the counter value to zero.
 *
 * By varying prefix strings, the user may avoid naming clashes between the
 * lightmaps in different worlds (if two worlds are to be resident in memory
 * simultaneously). Alternatively, lightmap texture names may be edited
 * directly (see \ref RpLtMapAtomicGetLightMap).
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  string  A pointer to a string from which to generate the names of
 *                 subsequently created lightmaps
 *
 * \return TRUE on success, FALSE otherwise
 *
 * \see RtLtMapGetDefaultPrefixString
 * \see RtLtMapGetLightMapCounter
 * \see RtLtMapSetLightMapCounter
 * \see RpLtMapAtomicGetLightMap
 * \see RpLtMapAtomicSetLightMap
 * \see RpLtMapWorldSectorGetLightMap
 * \see RpLtMapWorldSectorSetLightMap
 * \see RtLtMapLightMapsCreate
 */
RwBool
RtLtMapSetDefaultPrefixString(RwChar *string)
{
    RwUInt32 length;

    RWAPIFUNCTION(RWSTRING("RtLtMapSetDefaultPrefixString"));

    RWASSERT(NULL != string);

    length = rwstrlen(string);
    RWASSERT(length <= rpLTMAPMAXPREFIXSTRINGLENGTH);
    if (length > rpLTMAPMAXPREFIXSTRINGLENGTH)
    {
        RWRETURN(FALSE);
    }
    rwstrcpy(_rpLtMapGlobals.prefix, string);

    _rpLtMapGlobals.lightMapCount = 0;

    RWRETURN(TRUE);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapSetSliverAreaThreshold is used to set the threshold area
 * below which triangles are treated as slivers during lightmap
 * illumination.
 *
 * The calculation of normal vectors for triangles of a very small error
 * is subject to the numerical precision limitations of floating-point
 * numbers, hence triangles below a certain area are skipped during
 * lightmap illumination. The lightmap texels (if any) covered by
 * these triangles are filled in from neighboring triangles as a
 * post-process.
 *
 * This function allows to change the threshold area used, in case
 * certain user-created triangles happen to lie unfortunately on
 * the threshold. The symptom of a sliver triangle being lit which
 * should not be lit is usually that a line of lightmap texels on a
 * surface are assigned the incorrect color values (for example, if a
 * sliver has been determined to point in a strange direction, so the
 * lighting calculations may think it is pointing away from a light
 * whilst non-sliver triangles adjacent to it are pointing towards the
 * light). In such a case, increasing the sliver threshold value should
 * fix the problem.
 *
 * Note that increasing the threshold too far might make it impossible
 * for the post-process to accurately fill in all unprocessed lightmap
 * texels (resulting in uninitialized lightmap texels).
 *
 * The default sliver area threshold is given by the value of
 * rpLTMAPDEFAULTSLIVERAREATHRESHOLD.
 *
 * This function should be called before a call to
 * \ref RtLtMapIlluminate in order to have any effect.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  threshold  The new sliver triangle area threshold to set
 *
 * \return  TRUE on success, otherwise FALSE
 *
 * \see RtLtMapIlluminate
 * \see RtLtMapGetSliverAreaThreshold
 * \see RtLtMapGetVertexWeldThreshold
 * \see RtLtMapSetVertexWeldThreshold
 */
RwBool
RtLtMapSetSliverAreaThreshold(RwReal threshold)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapSetSliverAreaThreshold"));

    RWASSERT(threshold >= 0);

    _rpLtMapGlobals.sliverAreaThreshold = threshold;

    RWRETURN(TRUE);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapGetSliverAreaThreshold is used to retrieve the current
 * threshold area below which triangles are treated as slivers during
 * lightmap illumination.
 *
 * The calculation of normal vectors for triangles of a very small error
 * is subject to the numerical precision limitations of floating-point
 * numbers, hence triangles below a certain area are skipped during
 * lightmap illumination. The lightmap texels (if any) covered by
 * these triangles are filled in from neighboring triangles as a
 * post-process.
 *
 * This function allows to retrieve the threshold area used, in case
 * certain user-created triangles happen to lie unfortunately on
 * the threshold. The symptom of a sliver triangle being lit which
 * should not be lit is usually that a line of lightmap texels on a
 * surface are assigned the incorrect color values (for example, if a
 * sliver has been determined to point in a strange direction, so the
 * lighting calculations may think it is pointing away from a light
 * whilst non-sliver triangles adjacent to it are pointing towards the
 * light). In such a case, increasing the sliver threshold value should
 * fix the problem (see \ref RtLtMapSetSliverAreaThreshold)
 *
 * Note that increasing the threshold too far might make it impossible
 * for the post-process to accurately fill in all unprocessed lightmap
 * texels (resulting in uninitialized lightmap texels).
 *
 * The default sliver area threshold is given by the value of
 * rpLTMAPDEFAULTSLIVERAREATHRESHOLD.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \return  The current sliver area threshold value
 *
 * \see RtLtMapIlluminate
 * \see RtLtMapSetSliverAreaThreshold
 * \see RtLtMapGetVertexWeldThreshold
 * \see RtLtMapSetVertexWeldThreshold
 */
RwReal
RtLtMapGetSliverAreaThreshold(void)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapGetSliverAreaThreshold"));

    RWRETURN(_rpLtMapGlobals.sliverAreaThreshold);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapLightingSessionInitialize is used to initialize an
 * \ref RtLtMapLightingSession structure to a default form.
 *
 * This function sets the sessions' camera, atomicList, sectorList
 * and callback pointers to NULL. The startSample, numSamples and totalSamples
 * members are also set to zero. The session's world pointer is set up from a
 * parameter, since a session is not usable with a NULL world pointer.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtLtMapLightingSession structure to initialize
 * \param  world    A pointer to an \ref RpWorld for this session
 *
 * \return  A pointer to the initialized session on success, otherwise NULL
 *
 * \see RtLtMapLightingSessionDeInitialize
 * \see RtLtMapLightingSessionGetNumSamples
 * \see RtLtMapIlluminate
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapLightMapsClear
 * \see RtLtMapLightMapsDestroy
 * \see RtLtMapAreaLightGroupCreate
 * \see RtLtMapImagesPurge
 * \see RtLtMapTexDictionaryCreate
 * \if sky2 \see RtLtMapSkyLightingSessionBaseTexturesProcess \endif
 */
RtLtMapLightingSession *
RtLtMapLightingSessionInitialize(RtLtMapLightingSession *session,
                                 RpWorld *world)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapLightingSessionInitialize"));

    RWASSERT(NULL != session);
    RWASSERT(NULL != world);

    session->world            = world;                        /* Can't live wi'out this! */
    session->camera           = (RwCamera *)NULL;             /* Don't use a camera to cull lit objects */
    session->sectorList       = (RpWorldSector **)NULL;       /* Light all sectors in the world */
    session->numSectors       = 0;                            /* No sectors in the list */
    session->atomicList       = (RpAtomic **)NULL;            /* Light all atomics in the world */
    session->numAtomics       = 0;                            /* No atomics in the list */
    session->totalSamples     = 0;                            /* This gets filled by illuminate() */
    session->sampleCallBack   = RtLtMapDefaultSampleCallBack; /* The default sampleCallBack */
    session->visCallBack      = RtLtMapDefaultVisCallBack;    /* The default visCallBack */
    session->progressCallBack = NULL;                         /* No default progressCB */
    session->sampleMap        = NULL;                         /* No vismap created yet. */
    session->lightMapImg      = NULL;
    session->lightMap         = NULL;
    session->numTriNVert      = 0;
    session->totalTriNVert    = 0;
    session->invTotalTriNVert = 0;
    session->startObj         = 0;
    session->numObj           = 0;

    RWRETURN(session);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapLightingSessionDeInitialize is used to de-initialize a
 * \ref RtLtMapLightingSession structure to its default form by setting:
 *
 * \li The camera, atomicList, sectorList, world and callback pointers to NULL.
 * \li The startSample, numSamples and totalSamples members to zero.
 * \li Any temporary working memory free.
 *
 * To avoid memory leakage, call this function when a session is no longer
 * required.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtLtMapLightingSession structure to de-initialize
 *
 * \return  A pointer to the initialized session on success, otherwise NULL
 *
 * \see RtLtMapLightingSessionInitialize
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapLightMapsClear
 * \see RtLtMapLightMapsDestroy
 * \see RtLtMapImagesPurge
 */
RtLtMapLightingSession *
RtLtMapLightingSessionDeInitialize(RtLtMapLightingSession *session)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapLightingSessionDeInitialize"));
    RWASSERT(NULL != session);

    session->world            = NULL;                         /* Can't live wi'out this! */
    session->camera           = (RwCamera *)NULL;             /* Don't use a camera to cull lit objects */
    session->sectorList       = (RpWorldSector **)NULL;       /* Light all sectors in the world */
    session->numSectors       = 0;                            /* No sectors in the list */
    session->atomicList       = (RpAtomic **)NULL;            /* Light all atomics in the world */
    session->numAtomics       = 0;                            /* No atomics in the list */
    session->totalSamples     = 0;                            /* This gets filled by illuminate() */
    session->sampleCallBack   = RtLtMapDefaultSampleCallBack; /* The default sampleCallBack */
    session->visCallBack      = RtLtMapDefaultVisCallBack;    /* The default visCallBack */
    session->progressCallBack = NULL;                         /* No default progressCB */
    session->sampleMap        = NULL;                         /* No vismap created yet. */
    session->lightMapImg      = NULL;
    session->lightMap         = NULL;
    session->numTriNVert      = 0;
    session->totalTriNVert    = 0;
    session->invTotalTriNVert = 0;
    session->startObj         = 0;
    session->numObj           = 0;

    RWRETURN(session);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapWorldSectorGetLightMapSize is used to retrieve the size of lightmap
 * to be created for a given world sector.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  sector  A pointer to an sector
 *
 * \return  The size of lightmap which will be (or has been) created for this sector
 *
 * \see RtLtMapWorldSectorSetLightMapSize
 * \see RtLtMapWorldSectorGetFlags
 * \see RtLtMapWorldSectorSetFlags
 * \see RtLtMapLightMapsCreate
 */
RwUInt32
RtLtMapWorldSectorGetLightMapSize(RpWorldSector *sector)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapWorldSectorGetLightMapSize"));
    RWASSERT(NULL != sector);

    if (RPLTMAPWORLDSECTORGETDATA(sector)->lightMapSize > 0)
    {
        RWRETURN(RPLTMAPWORLDSECTORGETDATA(sector)->lightMapSize);
    }
    else
    {
        RWRETURN(_rpLtMapGlobals.lightMapSize);
    }
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapWorldSectorSetLightMapSize is used to set the size of lightmap to be
 * created for a given world sector.
 *
 * By default, the size of lightmap assigned to an object is determined by a
 * global default value (see \ref RtLtMapLightMapGetDefaultSize), but that
 * value may be overridden on a per-object basis by using this function.
 *
 * Note that you should only call this function before the sector's lightmap
 * is created by \ref RtLtMapLightMapsCreate, for obvious reasons.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  sector  A pointer to an sector
 * \param  size    The new lightmap size for the sector
 *
 * \return  A pointer to the sector on success, otherwise NULL
 *
 * \see RtLtMapWorldSectorGetFlags
 * \see RtLtMapWorldSectorSetFlags
 * \see RtLtMapLightMapsCreate
 */
RpWorldSector *
RtLtMapWorldSectorSetLightMapSize(RpWorldSector *sector, RwUInt32 size)
{
    LtMapObjectData *objectData;

    RWAPIFUNCTION(RWSTRING("RtLtMapWorldSectorSetLightMapSize"));
    RWASSERT(NULL != sector);

    /* Validate size */
    if (size < rpLTMAPMINLIGHTMAPSIZE)
    {
        RWASSERT(size >= rpLTMAPMINLIGHTMAPSIZE);
    }
    
    if (size & (size - 1))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtLtMapWorldSectorSetLightMapSize",
                           "Lightmap size must be a power of two");
        RWRETURN((RpWorldSector *)NULL);
    }

    objectData = RPLTMAPWORLDSECTORGETDATA(sector);
    RWASSERT(NULL == objectData->lightMap);
    /* We're cool */
    objectData->lightMapSize = size;

    RWRETURN(sector);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapAtomicGetLightMapSize is used to retrieve the size of lightmap
 * to be created for a given atomic.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an atomic
 *
 * \return  The size of lightmap which will be (or has been) created for this atomic
 *
 * \see RtLtMapAtomicSetLightMapSize
 * \see RtLtMapAtomicGetFlags
 * \see RtLtMapAtomicSetFlags
 * \see RtLtMapLightMapsCreate
 */
RwUInt32
RtLtMapAtomicGetLightMapSize(RpAtomic *atomic)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapAtomicGetLightMapSize"));
    RWASSERT(NULL != atomic);

    if (RPLTMAPATOMICGETDATA(atomic)->lightMapSize > 0)
    {
        RWRETURN(RPLTMAPATOMICGETDATA(atomic)->lightMapSize);
    }
    else
    {
        RWRETURN(_rpLtMapGlobals.lightMapSize);
    }
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapAtomicSetLightMapSize is used to set the size of lightmap to be
 * created for a given atomic.
 *
 * By default, the size of lightmap assigned to an object is determined by a
 * global default value (see \ref RtLtMapLightMapGetDefaultSize), but that
 * value may be overridden on a per-object basis by using this function.
 *
 * Note that you should only call this function before the atomic's lightmap
 * is created by \ref RtLtMapLightMapsCreate, for obvious reasons.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an atomic
 * \param  size    The new lightmap size for the atomic
 *
 * \return  A pointer to the atomic on success, otherwise NULL
 *
 * \see RtLtMapAtomicGetLightMapSize
 * \see RtLtMapAtomicGetFlags
 * \see RtLtMapAtomicSetFlags
 * \see RtLtMapLightMapsCreate
 */
RpAtomic *
RtLtMapAtomicSetLightMapSize(RpAtomic *atomic, RwUInt32 size)
{
    LtMapObjectData *objectData;

    RWAPIFUNCTION(RWSTRING("RtLtMapAtomicSetLightMapSize"));

    /* Validate size */
    if (size < rpLTMAPMINLIGHTMAPSIZE)
    {
        RWASSERT(size >= rpLTMAPMINLIGHTMAPSIZE);
        RWRETURN((RpAtomic *)NULL);
    }
    
    if (size & (size - 1))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtLtMapAtomicSetLightMapSize",
                           "Lightmap size must be a power of two");
        RWRETURN((RpAtomic *)NULL);
    }

    objectData = RPLTMAPATOMICGETDATA(atomic);
    RWASSERT(NULL == objectData->lightMap);
    /* We're cool */
    objectData->lightMapSize = size;

    RWRETURN(atomic);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapWorldSectorGetFlags is used to retrieve lightmap-related flags
 * for a given world sector.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  sector  A pointer to a world sector
 *
 * \return  A pointer to the world sector's flags on success, otherwise NULL
 *
 * \see RtLtMapWorldSectorSetFlags
 * \see RtLtMapAtomicGetFlags
 * \see RtLtMapAtomicSetFlags
 * \see RtLtMapMaterialGetFlags
 * \see RtLtMapMaterialSetFlags
 * \see RtLtMapLightMapsCreate
 */
RwUInt32
RtLtMapWorldSectorGetFlags(RpWorldSector *sector)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapWorldSectorGetFlags"));
    RWASSERT(NULL != sector);

    RWRETURN(RPLTMAPWORLDSECTORGETDATA(sector)->flags);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapWorldSectorSetFlags is used to set lightmap-related flags
 * for a given world sector.
 *
 * Note that you cannot change the rtLTMAPOBJECTLIGHTMAP flag for
 * a world sector after \ref RtLtMapLightMapsCreate has created a lightmap
 * for that sector (see \ref RtLtMapObjectFlags).
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  sector  A pointer to a world sector
 * \param  flags   The new lightmap-related flags for this sector
 *
 * \return  A pointer to the sector on success, otherwise NULL
 *
 * \see RtLtMapWorldSectorGetFlags
 * \see RtLtMapAtomicGetFlags
 * \see RtLtMapAtomicSetFlags
 * \see RtLtMapMaterialGetFlags
 * \see RtLtMapMaterialSetFlags
 * \see RtLtMapLightMapsCreate
 */
RpWorldSector *
RtLtMapWorldSectorSetFlags(RpWorldSector *sector, RwUInt32 flags)
{
    LtMapObjectData *objectData;

    RWAPIFUNCTION(RWSTRING("RtLtMapWorldSectorSetFlags"));

    RWASSERT(NULL != sector);
    objectData = RPLTMAPWORLDSECTORGETDATA(sector);

    /* Validate flag changes */
    if ((NULL != objectData->lightMap) && (!(flags & rtLTMAPOBJECTLIGHTMAP)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtLtMapWorldSectorSetFlags",
            "The rtLTMAPOBJECTLIGHTMAP flag may not be changed whilst the sector has a lightmap. Call RtLtMapWorldSectorLightMapDestroy first.");
        RWRETURN((RpWorldSector *)NULL);
    }
    if ((flags & rtLTMAPOBJECTVERTEXLIGHT) &&
        ((!(RpWorldGetFlags(RpWorldSectorGetWorld(sector)) & rpWORLDNORMALS)) ||
         (!(RpWorldGetFlags(RpWorldSectorGetWorld(sector)) & rpWORLDPRELIT))) )
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtLtMapWorldSectorSetFlags",
            "The rtLTMAPOBJECTVERTEXLIGHT flag may not be set for objects without vertex normals and prelight colors.");
        RWRETURN((RpWorldSector *)NULL);
    }

    /* We're cool */
    objectData->flags = flags;

    RWRETURN(sector);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapAtomicGetFlags is used to retrieve lightmap-related flags
 * for a given atomic.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an atomic
 *
 * \return  The atomic's flags
 *
 * \see RtLtMapAtomicSetFlags
 * \see RtLtMapWorldSectorGetFlags
 * \see RtLtMapWorldSectorSetFlags
 * \see RtLtMapMaterialGetFlags
 * \see RtLtMapMaterialSetFlags
 * \see RtLtMapLightMapsCreate
 */
RwUInt32
RtLtMapAtomicGetFlags(RpAtomic *atomic)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapAtomicGetFlags"));
    RWASSERT(NULL != atomic);

    RWRETURN(RPLTMAPATOMICGETDATA(atomic)->flags);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapAtomicSetFlags is used to set lightmap-related flags
 * for a given atomic.
 *
 * Note that you cannot change the rtLTMAPOBJECTLIGHTMAP flag for
 * an atomic after \ref RtLtMapLightMapsCreate has created a lightmap
 * for that atomic (see \ref RtLtMapObjectFlags).
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param atomic  A pointer to an atomic
 * \param flags   The new lightmap-related flags for this atomic
 *
 * \return  A pointer to the atomic on success, otherwise NULL
 *
 * \see RtLtMapAtomicGetFlags
 * \see RtLtMapWorldSectorGetFlags
 * \see RtLtMapWorldSectorSetFlags
 * \see RtLtMapMaterialGetFlags
 * \see RtLtMapMaterialSetFlags
 * \see RtLtMapLightMapsCreate
 */
RpAtomic *
RtLtMapAtomicSetFlags(RpAtomic *atomic, RwUInt32 flags)
{
    LtMapObjectData *objectData;
    RpGeometry *geom;

    RWAPIFUNCTION(RWSTRING("RtLtMapAtomicSetFlags"));
    objectData = RPLTMAPATOMICGETDATA(atomic);

    /* Validate flag changes */
    if ((NULL != objectData->lightMap) && (!(flags & rtLTMAPOBJECTLIGHTMAP)))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtLtMapAtomicSetFlags",
            "The rtLTMAPOBJECTLIGHTMAP flag may not be changed whilst the atomic has a lightmap. Call RtLtMapAtomicLightMapDestroy first.");
        RWRETURN((RpAtomic *)NULL);
    }
    geom = RpAtomicGetGeometry(atomic);
    if ((flags & rtLTMAPOBJECTVERTEXLIGHT) &&
        ((!(RpGeometryGetFlags(geom) & rpGEOMETRYNORMALS)) ||
         (!(RpGeometryGetFlags(geom) & rpGEOMETRYPRELIT))))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtLtMapAtomicSetFlags",
            "The rtLTMAPOBJECTVERTEXLIGHT flag may not be set for objects without vertex normals and prelight colors.");
        RWRETURN((RpAtomic *)NULL);
    }

    /* We're cool */
    objectData->flags = flags;

    RWRETURN(atomic);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapLightMapGetDefaultSize is used to retrieve the size of
 * lightmaps which will subsequently be created.
 *
 * The global default lightmap size value may be overridden on a per
 * object basis (see \ref RtLtMapAtomicSetLightMapSize).
 *
 * The default size of lightmaps on startup is given by the value
 * rpLTMAPDEFAULTLIGHTMAPSIZE and can be overridden with this function.
 * Lightmaps are always square and must have sides a power of two in
 * length.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \return  The current default lightmap size
 *
 * \see RtLtMapLightMapSetDefaultSize
 * \see RtLtMapAtomicSetLightMapSize
 * \see RtLtMapWorldSectorSetLightMapSize
 * \see RtLtMapLightMapsCreate
 */
RwUInt32
RtLtMapLightMapGetDefaultSize(void)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapLightMapGetDefaultSize"));
    RWASSERT(_rpLtMapGlobals.module.numInstances > 0);

    RWRETURN(_rpLtMapGlobals.lightMapSize);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapLightMapSetDefaultSize specifies the size of lightmaps
 * which will subsequently be created.
 *
 * The global default lightmap size value may be overridden on a per
 * object basis (see \ref RtLtMapAtomicSetLightMapSize).
 *
 * The default size of lightmaps on startup is given by the value
 * rpLTMAPDEFAULTLIGHTMAPSIZE and can be overridden with this function.
 * Lightmaps are always square and must have sides a power of two in
 * length.
 *
 * This function should be called before \ref RtLtMapLightMapsCreate
 * if it is to have any effect.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  size  The size of subsequently-created lightmaps
 *
 * \return  TRUE on success, otherwise FALSE
 *
 * \see RtLtMapLightMapGetDefaultSize
 * \see RtLtMapAtomicSetLightMapSize
 * \see RtLtMapWorldSectorSetLightMapSize
 * \see RtLtMapLightMapsCreate
 */
RwBool
RtLtMapLightMapSetDefaultSize(RwUInt32 size)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapLightMapSetDefaultSize"));
    RWASSERT(0 < _rpLtMapGlobals.module.numInstances);

    /* Validate size */
    if (size < rpLTMAPMINLIGHTMAPSIZE)
    {
        RWASSERT(size >= rpLTMAPMINLIGHTMAPSIZE);
    }

    if (size & (size - 1))
    {
        RwDebugSendMessage(rwDEBUGERROR, "RtLtMapLightMapSetDefaultSize",
                           "Lightmap size must be a power of two");
        RWRETURN(FALSE);
    }

    /* We're cool */
    _rpLtMapGlobals.lightMapSize = size;

    RWRETURN(TRUE);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapSetVertexWeldThreshold is used to set the threshold distance
 * below which triangle vertices are treated as being at the same position
 * during lightmap UV calculation.
 *
 * The calculation of per-vertex lightmap UV coordinates, during
 * \ref RtLtMapLightMapsCreate, makes the assumption that adjacent
 * triangles which have different vertices, but whose vertices share
 * the same position, should be grouped together (and thus be adjacent
 * in) the lightmap of the current object. This means that lightmap
 * texels will be shared across the two triangles.
 *
 * The vertex welding threshold distance is used to determin whether two
 * vertices are at the same position. The distance used should be the
 * same as that used during the export of objects from the user's
 * modelling package. If the threshold is too large, then triangles will
 * be inappropriately grouped, which could cause artifacts during
 * lightmap illumination. If the threshold is too large, then more
 * triangles will be split up than necessary in the object's lightmap,
 * resulting in less efficient use of the lightmap's texels.
 *
 * The default vertex welding threshold distance is given by the value
 * of rpLTMAPDEFAULTVERTEXWELDTHRESHOLD.
 *
 * This function should be called before a call to
 * \ref RtLtMapLightMapsCreate in order to have any effect.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  threshold  The new vertex-welding threshold to set
 *
 * \return  TRUE on success, otherwise FALSE
 *
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapGetSliverAreaThreshold
 * \see RtLtMapSetSliverAreaThreshold
 * \see RtLtMapGetVertexWeldThreshold
 */
RwBool
RtLtMapSetVertexWeldThreshold(RwReal threshold)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapSetVertexWeldThreshold"));

    RWASSERT(threshold >= 0);

    _rpLtMapGlobals.vertexWeldThreshold = threshold;

    RWRETURN(TRUE);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapGetVertexWeldThreshold is used to retrieve the current
 * threshold distance below which triangle vertices are treated as being
 * at the same position during lightmap UV calculation.
 *
 * The calculation of per-vertex lightmap UV coordinates, during
 * \ref RtLtMapLightMapsCreate, makes the assumption that adjacent
 * triangles which have different vertices, but whose vertices share
 * the same position, should be grouped together (and thus be adjacent
 * in) the lightmap of the current object. This means that lightmap
 * texels will be shared across the two triangles.
 *
 * The vertex welding threshold distance is used to determin whether two
 * vertices are at the same position. The distance used should be the
 * same as that used during the export of objects from the user's
 * modelling package. If the threshold is too large, then triangles will
 * be inappropriately grouped, which could cause artifacts during
 * lightmap illumination. If the threshold is too large, then more
 * triangles will be split up than necessary in the object's lightmap,
 * resulting in less efficient use of the lightmap's texels.
 *
 * The default vertex welding threshold distance is given by the value
 * of rpLTMAPDEFAULTVERTEXWELDTHRESHOLD.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \return  The current vertex welding threshold distane
 *
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapGetSliverAreaThreshold
 * \see RtLtMapSetSliverAreaThreshold
 * \see RtLtMapSetVertexWeldThreshold
 */
RwReal
RtLtMapGetVertexWeldThreshold(void)
{
    RWAPIFUNCTION(RWSTRING("RtLtMapGetVertexWeldThreshold"));

    RWRETURN(_rpLtMapGlobals.vertexWeldThreshold);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapLightMapsCreate creates lightmaps for the objects specified within
 * an \ref RtLtMapLightingSession.
 *
 * This function traverses the objects specified by the received
 * \ref RtLtMapLightingSession structure. Only atomics flagged as rpATOMICRENDER
 * will be used. Note that the camera member of this structure is used.
 *
 * Any given atomic or world sector may reference at most one lightmap. A single
 * lightmap may, however, be referenced by multiple such objects. Note that this
 * lightmap 'sharing' will only occur between the objects specified within the
 * received \ref RtLtMapLightingSession. Hence, if objects are passed to this
 * function one by one, no lightmap sharing will occur.
 *
 * In creating a lightmap for a given object, each triangle in the object must
 * be placed within the lightmap (i.e have its second set of UV coordinates set
 * up). This process is fairly complex and slow, due to two considerations.
 * Firstly, to minimize the usage of video memory by lightmaps, object triangles
 * must be packed into lightmaps as tightly as possible - this is a variant of
 * the 'knapsack problem', which is non-trivial. Secondly, this implementation
 * of lightmaps is designed to work with tristripped geometry, for efficiency
 * (most lightmap implementations require trilist geometry as it simplifies
 * many aspects of lightmap generation, such as this one, greatly). This requires
 * analysing surface topology and taking several precautions to avoid visual
 * artifacts, but the result is that fewer lightmap texels are consumed per
 * triangle (since adjacent triangles can share lightmap texels) and that
 * lightmapped geometry renders much more quickly (especially on platforms such
 * as PlayStation 2).
 *
 * Lightmap UV coordinates are calculated such as to distribute lighting sample
 * points (lightmap texels) uniformly over geometry, at a density (in world-
 * space) specified by the density parameter of this function. This density may
 * be modified on a per-material basis (see
 * \ref RtLtMapMaterialSetLightMapDensityModifier).
 *
 * If, given the specified lightmap density, a particular sector or atomic
 * contains triangles of too great an area to fit into a single lightmap, the
 * lightmap density of those triangles is halved. This is repeated until the
 * triangles fit or the process fails. Hence, it is recommended to choose
 * lightmap density and object size (e.g by controlling BSP sectorization)
 * such that this shrinkage need not occur (a rough rule of thumb is to ensure
 * that "density*objectSize < lightMapSize"). Debug stream messages will be
 * issued if it does.
 *
 * The size of lightmap assigned to each object is determined by a global
 * value (see \ref RtLtMapLightMapSetDefaultSize), which may be overridden
 * on a per-object basis (see \ref RtLtMapAtomicSetLightMapSize).
 *
 * Lightmaps are named automatically (see \ref RtLtMapGetDefaultPrefixString)
 * but they may be renamed (see \ref RpLtMapAtomicSetLightMap) and/or
 * otherwise modified before they are saved to disk. Lightmaps automatically
 * get added to the current texture dictionary on creation.
 *
 * By default, this function will initialize lightmap colors to a black and
 * white checkerboard. If the color parameter is non-NULL, lightmaps will be
 * cleared to this color instead (note that the alpha channel is set to an
 * internally-used value in all cases).
 *
 * In addition to creating lightmaps, this function also changes the
 * object pipelines of the affected sectors and atomics, setting them to
 * use platform-specific lightmap rendering pipelines.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtLtMapLightingSession
 * \param  density  A \ref RwReal specifying the number of lightmap texels
 *                  per unit worldspace
 * \param  color    An optional pointer to an \ref RwRGBA specifying the
 *                  color to which to clear the new lightmaps
 *
 * \return  A pointer to the lighting session on success, otherwise NULL
 *
 * \see RtLtMapLightMapsDestroy
 * \see RtLtMapLightMapsClear
 * \see RtLtMapMaterialGetLightMapDensityModifier
 * \see RtLtMapMaterialSetLightMapDensityModifier
 * \see RtLtMapLightMapSetDefaultSize
 * \see RtLtMapAtomicSetLightMapSize
 * \see RtLtMapWorldSectorSetLightMapSize
 * \see RtLtMapGetDefaultPrefixString
 * \see RtLtMapSetDefaultPrefixString
 * \see RpLtMapAtomicGetLightMap
 * \see RpLtMapAtomicSetLightMap
 * \see RpLtMapWorldSectorGetLightMap
 * \see RpLtMapWorldSectorSetLightMap
 * \see RpLtMapGetPlatformWorldSectorPipeline
 * \see RpLtMapGetPlatformAtomicPipeline
 * \see RtLtMapGetVertexWeldThreshold
 * \see RtLtMapSetVertexWeldThreshold
 */
RtLtMapLightingSession *
RtLtMapLightMapsCreate(RtLtMapLightingSession *session,
                           RwReal density,
                           RwRGBA *color)
{
    LtMapSessionInfo sessionInfo;
    LtMapObjectData *objectData;
    LtMapWorldData  *worldData;
    LtMapAllocUVData allocUVData;
    RwUInt32 i;

    RWAPIFUNCTION(RWSTRING("RtLtMapLightMapsCreate"));
    RWASSERT(_rpLtMapGlobals.module.numInstances > 0);
    RWASSERT(density > 0);

    RWASSERT(NULL != session);
    RWASSERT(NULL != session->world);

    /* If lightmaps exist already, purge them */
    RtLtMapLightMapsDestroy(session);

    /* Create the Slist */
    RWASSERT (rtLtMapGlobals.ltMapSlots == NULL);
    rtLtMapGlobals.ltMapSlots = _rwSListCreate(sizeof(LtMapSlot),
        rwID_LTMAPPLUGIN | rwMEMHINTDUR_EVENT);

    /* Get local lists of sectors/atomics from the session
     * (culled w.r.t the incoming camera and object lists, if present) */
    _rtLtMapLightingSessionInfoCreate(&sessionInfo, session, TRUE);

    /* Check 2 UV sets on world if needed */
    for (i = 0;i < (RwUInt32)sessionInfo.numSectors;i++)
    {
        RpWorldSector *sector = *(RpWorldSector **)rwSListGetEntry(sessionInfo.localSectors, i);
        objectData = RPLTMAPWORLDSECTORGETDATA(sector);

        /* Don't lightmap space-filling sectors or those
         * not flagged with rtLTMAPOBJECTLIGHTMAP */
        if ((objectData->flags & rtLTMAPOBJECTLIGHTMAP) && (sector->numTriangles > 0) )
        {
            if (!(RpWorldGetFlags(session->world) & rpWORLDTEXTURED2))
            {
                RwDebugSendMessage(rwDEBUGERROR, "RtLtMapLightMapsCreate",
                    "World must contain at least two texture coordinate sets");
                _rtLtMapLightingSessionInfoDestroy(&sessionInfo);
                RWRETURN((RtLtMapLightingSession *)NULL);
            }
        }
    }

    /* This gets multiplied by global and per-material
     * lightmap and arealight sample density modifiers */
    worldData = RPLTMAPWORLDGETDATA(session->world);
    worldData->lightMapDensity = density;
    worldData->flag |= rpLTMAPWORLDFLAGLIGHTMAP;

    /* We store lightmaps in gLtMapSlots[] during building */
    allocUVData.world   = session->world;
    allocUVData.slots = NULL;

    /* LtMapWorldSectorAllocateUV sets up the appropriate render pipelines */
    for (i = 0;i < (RwUInt32)sessionInfo.numSectors;i++)
    {
        RpWorldSector *sector = *(RpWorldSector **)rwSListGetEntry(sessionInfo.localSectors, i);
        objectData = RPLTMAPWORLDSECTORGETDATA(sector);

        /* Don't lightmap space-filling sectors or those
         * not flagged with rtLTMAPOBJECTLIGHTMAP */
        if ((objectData->flags & rtLTMAPOBJECTLIGHTMAP) && (sector->numTriangles > 0) )
        {
            _rtLtMapWorldSectorAllocateUV(session, sector, &allocUVData);
        }

        /* Record the color */
        if (NULL != color)
        {
            objectData->clearCol = TRUE;
            objectData->color = *color;
        }
        else
        {
            objectData->clearCol = FALSE;
        }
    }

    /* LtMapAtomicAllocateUV sets up the appropriate render pipelines */
    for (i = 0;i < (RwUInt32)sessionInfo.numAtomics;i++)
    {
        RpAtomic *atomic = *(RpAtomic **)rwSListGetEntry(sessionInfo.localAtomics, i);
        RpGeometry *geom = RpAtomicGetGeometry(atomic);
        objectData = RPLTMAPATOMICGETDATA(atomic);

        /* Only lightmap atomics flagged with rpATOMICRENDER and
         * rtLTMAPOBJECTLIGHTMAP (also, paranoidly check for empty atomics). */
        if ((RpAtomicGetFlags(atomic) & rpATOMICRENDER) &&
            (objectData->flags & rtLTMAPOBJECTLIGHTMAP) &&
            (RpGeometryGetNumTriangles(geom) > 0) )
        {
            _rtLtMapAtomicAllocateUV(session, atomic, &allocUVData);
        }

        /* Record the color */
        if (NULL != color)
        {
            objectData->clearCol = TRUE;
            objectData->color = *color;
        }
        else
        {
            objectData->clearCol = FALSE;
        }
    }

#ifdef SHOWLIGHTMAPUSAGE
    {
        RwUInt32            numSlots;

        /* Complete colouring in lightmaps to clearly show usage */

        numSlots = _rwSListGetNumEntries(rtLtMapGlobals.ltMapSlots);

        for (i = 0;i < numSlots;i++)
        {
            static RwChar string[256];
            RwUInt32  numUsed = 0, numWasted = 0, numUnInit = 0;
            RwRaster *raster = RwTextureGetRaster(allocUVData.slots[i].lightMap);
            RwUInt32  width, height, stride;
            RwImage  *image;
            RwUInt8  *pixels;
            RwUInt32 j, x, y;

            for (j = 0;j < allocUVData.slots[i].count;j++)
            {
                /* Fill free space with a random bright green */
                RwRGBA unUsedColour = {0, 128, 0, 255};
                unUsedColour.green += 127 & RpRandom();
                RasterRectClear(raster, &(allocUVData.slots[i].rects[j]), unUsedColour);
            }

            /* Work out usage/wastage
            * Red is wasted space
            * Green is free space
            * Yellow is used space
            * Blue is uninitialised space (shouldn't see this) */
            width  = RwRasterGetWidth( raster);
            height = RwRasterGetHeight(raster);
            image = RwImageCreate(width, height, 32);
            RWASSERT(NULL != image);

            RwImageAllocatePixels(image);
            RwImageSetFromRaster(image, raster);
            stride = RwImageGetStride(image);
            pixels = RwImageGetPixels(image);
            for (y = 0;y < height;y++)
            {
                RwRGBA *col = (RwRGBA *)&(pixels[y * stride]);
                for (x = 0;x < width;x++)
                {
                    RwInt32 redMinusGreen;
                    redMinusGreen = (RwInt32)col->red - (RwInt32)col->green;
                    if  (redMinusGreen >= 128)
                    {
                        numWasted++; /* Red, wasted space */
                    }
                    else if (redMinusGreen > -128)
                    {
                        numUsed++; /* Yellow, used space */
                    }
                    if (col->blue)
                        numUnInit++;
                    col++;
                }
            }
            RWASSERT(0 == numUnInit);
            rwsprintf(string, "[lightmap %d] Used: %.1f%%  Wasted: %.1f%%",
                    i, 100 * (numUsed   / (RwReal)(width*height)),
                       100 * (numWasted / (RwReal)(width*height)));
            RwDebugSendMessage(
                rwDEBUGMESSAGE, "RtLtMapLightMapsCreate", string);
            RwImageDestroy(image);

            /* We turned auto-mipmapping off in RasterRectClear(),
            * so we have to reinstate it now and update mipmaps */
            if (RpLtMapGetRasterFormat() & rwRASTERFORMATAUTOMIPMAP)
            {
                RWASSERT((RwUInt32)RwRasterGetFormat(raster) ==
                    ((RpLtMapGetRasterFormat() & rwRASTERFORMATMASK) &
                    (~rwRASTERFORMATAUTOMIPMAP)) );
                /* Naughty but hey... */
                raster->cFormat |= rwRASTERFORMATAUTOMIPMAP >> 8;
                RwRasterLock(raster, 0, rwRASTERLOCKREADWRITE);
                RwRasterUnlock(raster);
            }
        }
    }

#else

    /* Clear the lightmaps to a visibly recognisable state
     * (this will create the images too, also in a cleared state) */
    RtLtMapLightMapsClear(session, color);

#endif /* def SHOWLIGHTMAPUSAGE */

    /* Probably a good idea, given we're changing
     * pipelines and modifying UV data. */
    RwResourcesEmptyArena();

    _rtLtMapLightingSessionInfoDestroy(&sessionInfo);

    for (i = 0; i < (RwUInt32) _rwSListGetNumEntries (rtLtMapGlobals.ltMapSlots); i++)
    {
        /* The sample maps and light maps should not be destroyed
         * by this, as the atomics and world sectors still
         * have references to them */
        _rpLtMapSampleMapDestroy (allocUVData.slots [i].sampleMap);
        RwTextureDestroy         (allocUVData.slots [i].lightMap );
    }
    _rwSListEmpty(rtLtMapGlobals.ltMapSlots);
    _rwSListDestroy(rtLtMapGlobals.ltMapSlots);
    rtLtMapGlobals.ltMapSlots = NULL;

    RWRETURN(session);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapAtomicLightMapDestroy destroys the lightmap (if any)
 * associated with a given atomic.
 *
 * Note that this function destroys the intermediate sample map attached
 * to the object, if it exists. Hence it is not necessary
 * to call \ref RtLtMapAtomicImagePurge before calling this function.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  atomic  A pointer to an \ref RpAtomic
 *
 * \return  A pointer to the atomic on success, otherwise NULL
 *
 * \see RtLtMapWorldSectorLightMapDestroy
 * \see RtLtMapLightMapsDestroy
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapLightMapsClear
 * \see RpLtMapAtomicGetLightMap
 * \see RpLtMapAtomicSetLightMap
 * \see RpLtMapWorldSectorGetLightMap
 * \see RpLtMapWorldSectorSetLightMap
 */
RpAtomic *
RtLtMapAtomicLightMapDestroy(RpAtomic *atomic)
{
    LtMapObjectData *objectData;
    LtMapGeometryData *geometryData;

    RWAPIFUNCTION(RWSTRING("RtLtMapAtomicLightMapDestroy"));

    RWASSERT(NULL != atomic);
    objectData = RPLTMAPATOMICGETDATA(atomic);

    /* Destroy the lightmap and image if present */
    if (NULL != objectData->lightMap)
    {
        RwTextureDestroy(objectData->lightMap);
        objectData->lightMap = (RwTexture *)NULL;
        /* It initialised when lightmaps are created, ergo clear the value here */
        objectData->numSamples = 0;
        /* It's no longer lightmapped, ergo reset it to use the default pipeline */
        RpAtomicSetPipeline(atomic, (RxPipeline *)NULL);
    }

    if (NULL != objectData->sampleMap)
    {
        _rpLtMapSampleMapDestroy(objectData->sampleMap);
    }

    /* Destroy the PolySet array associated with the geometry */
    geometryData = RPLTMAPGEOMETRYGETDATA (RpAtomicGetGeometry (atomic));
    if (geometryData->PolySetArray != NULL)
    {
        RwInt32 j;

        /* Reset the UV2s so that LightMapsCreate() will work again */
        /* TODO[2][AAO]: REALLY NEED A FLAG PER-ATOMIC/SECTOR THAT SAYS "UNINITIALISED"
         *               SO YOU KNOW WHAT STATE THE UVS ARE IN... */
        _rtLtMapGeometryResetUVs (RpAtomicGetGeometry (atomic));

        /* Release the polysets */
        for (j = 0; j < geometryData->numSets; j++)
        {
            rwSListDestroy(geometryData->PolySetArray [j].members);
        }
        
        RwFree (geometryData->PolySetArray);
        geometryData->PolySetArray = NULL;
    }

    objectData->sampleMap = NULL;

    RWRETURN(atomic);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapWorldSectorLightMapDestroy destroys the lightmap (if any)
 * associated with a given world sector.
 *
 * Note that this function destroys the intermediate sample map attached
 * to the object, if it exists. Hence it is not necessary
 * to call \ref RtLtMapWorldSectorImagePurge before calling this function.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  sector  A pointer to an \ref RpWorldSector
 *
 * \return  A pointer to the world sector on success, otherwise NULL
 *
 * \see RtLtMapAtomicLightMapDestroy
 * \see RtLtMapLightMapsDestroy
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapLightMapsClear
 * \see RpLtMapAtomicGetLightMap
 * \see RpLtMapAtomicSetLightMap
 * \see RpLtMapWorldSectorGetLightMap
 * \see RpLtMapWorldSectorSetLightMap
 */
RpWorldSector *
RtLtMapWorldSectorLightMapDestroy(RpWorldSector *sector)
{
    LtMapObjectData *objectData;

    RWAPIFUNCTION(RWSTRING("RtLtMapWorldSectorLightMapDestroy"));

    RWASSERT(NULL != sector);
    objectData = RPLTMAPWORLDSECTORGETDATA(sector);

    /* Destroy the lightmap and image if present */
    if (NULL != objectData->lightMap)
    {
        RwTextureDestroy(objectData->lightMap);
        objectData->lightMap = (RwTexture *)NULL;
        /* Reset the UV2s so that LightMapsCreate() will work again */
/* TODO[2][AAO]: REALLY NEED A FLAG PER-ATOMIC/SECTOR THAT SAYS "UNINITIALISED"
 *               SO YOU KNOW WHAT STATE THE UVS ARE IN... */
        _rtLtMapWorldSectorResetUVs(sector);
        /* It initialised when lightmaps are created, ergo clear the value here */
        objectData->numSamples = 0;
        /* It's no longer lightmapped, ergo reset it to use the default pipeline */
        RpWorldSectorSetPipeline(sector, (RxPipeline *)NULL);
    }

    if (NULL != objectData->sampleMap)
    {
        _rpLtMapSampleMapDestroy(objectData->sampleMap);
    }

    objectData->sampleMap = NULL;

    RWRETURN(sector);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapLightMapsDestroy destroys the lightmaps (if any)
 * associated with the objects in an \ref RtLtMapLightingSession.
 *
 * This function traverses the objects specified by the received
 * \ref RtLtMapLightingSession structure. Only atomics flagged as
 * rpATOMICRENDER will be used. Note that the camera member of this
 * structure is used.
 *
 * Note that this function destroys the intermediate sample map attached
 * to the objects, if they exist. Hence it is not necessary
 * to call \ref RtLtMapImagesPurge before calling this function.
 *
 * The lightmap plugin must be attached before using this function.
 *
 * \param  session  A pointer to an \ref RtLtMapLightingSession
 *
 * \return  A pointer to the session on success, otherwise NULL
 *
 * \see RtLtMapAtomicLightMapDestroy
 * \see RtLtMapWorldSectorLightMapDestroy
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapLightMapsClear
 * \see RpLtMapAtomicGetLightMap
 * \see RpLtMapAtomicSetLightMap
 * \see RpLtMapWorldSectorGetLightMap
 * \see RpLtMapWorldSectorSetLightMap
 */
void
RtLtMapLightMapsDestroy(RtLtMapLightingSession *session)
{
    LtMapSessionInfo sessionInfo;
    LtMapWorldData  *worldData;
    RwUInt32 i;

    RWAPIFUNCTION(RWSTRING("RtLtMapLightMapsDestroy"));

    RWASSERT(NULL != session);
    RWASSERT(NULL != session->world);

    /* Get local lists of sectors/atomics from the session
     * (culled w.r.t the incoming camera and object lists, if present) */
    _rtLtMapLightingSessionInfoCreate(&sessionInfo, session, TRUE);

    for (i = 0;i < (RwUInt32)sessionInfo.numSectors;i++)
    {
        RpWorldSector *sector = *(RpWorldSector **)rwSListGetEntry(sessionInfo.localSectors, i);

        /* This will reset UV2s to the axis-representative
         * values so that LightMapsCreate() will work again
         * and it also resets to the default pipeline */
        RtLtMapWorldSectorLightMapDestroy(sector);
    }

    for (i = 0;i < (RwUInt32)sessionInfo.numAtomics;i++)
    {
        RpAtomic *atomic = *(RpAtomic **)rwSListGetEntry(sessionInfo.localAtomics, i);

        if (RpAtomicGetFlags(atomic) & rpATOMICRENDER)
        {
            /* This will reset UV2s to the axis-representative
             * values so that LightMapsCreate() will work again
             * and it also resets to the default pipeline */
            RtLtMapAtomicLightMapDestroy(atomic);
        }
    }

    _rtLtMapLightingSessionInfoDestroy(&sessionInfo);


    if (NULL != rtLtMapGlobals.ltMapSlots)
    {
        _rwSListEmpty(rtLtMapGlobals.ltMapSlots);

        _rwSListDestroy(rtLtMapGlobals.ltMapSlots);
    }

    rtLtMapGlobals.ltMapSlots = NULL;

    /* This gets multiplied by global and per-material
     * lightmap and arealight sample density modifiers */
    worldData = RPLTMAPWORLDGETDATA(session->world);
    worldData->flag &= ~rpLTMAPWORLDFLAGLIGHTMAP;

    RWRETURNVOID();
}

/*
 ****************************************************************************
 */
static RwReal
LtMapCalculateCumulateArea (RwV3d *vtx, RpTriangle *triangles,
                            RwUInt32 numTriangles, RpMaterialList *matList, RwUInt32 matListBase)
{
    RwReal cumulatedArea = 0.0f;
    RwUInt32 i;
    RwReal density;
    RpMaterial *mat;

    RWFUNCTION (RWSTRING ("LtMapCalculateCumulateArea"));

    for(i=0;i<numTriangles;i++)
    {
        RwV3d impT[3];
        RwV3d e01, e12;
        RwReal area;
        RwV3d cross;

        /* Get the vertices for the triangle corners */
        RwV3dAssign(&impT[0],&vtx[triangles [i].vertIndex[0]]);
        RwV3dAssign(&impT[1],&vtx[triangles [i].vertIndex[1]]);
        RwV3dAssign(&impT[2],&vtx[triangles [i].vertIndex[2]]);

        /* Calculate edges 01 & 12 */
        RwV3dSub(&e01,&impT[0],&impT[1]);
        RwV3dSub(&e12,&impT[1],&impT[2]);

        /* area = |01 x 12| / 2 */
        RwV3dCrossProduct (&cross, &e01, &e12);
        area = RwV3dLength (&cross) / 2.0f;

        /* Obtain material density */
        mat = rpMaterialListGetMaterial (matList, triangles [i].matIndex + matListBase);
        density = RtLtMapMaterialGetLightMapDensityModifier (mat);

        /* The lightmapping algorithm drops non-lightmapped materials
         * down to 1/16 the original density to save space.  I think
         * this means that they're still lightmapped. */
        if (!(RtLtMapMaterialGetFlags(mat) & rtLTMAPMATERIALLIGHTMAP))
        {
            /* Reduce density ridiculously for non-lightmapped geom,
             * so we don't waste lightmap space on it */
            density *= 0.0625f; /* =1/16 */
        }

        /* Scale area according to material density */
        area *= (density * density);

        cumulatedArea += area;
    }

    RWRETURN (cumulatedArea);
}

/*
 ****************************************************************************
 */
static RpWorldSector *
_rtLtMapWorldDensityCB(RpWorldSector *ws, void *data)
{
    RwUInt32                numTriangles;
    _rtdensityCalculateData *cdata     = (_rtdensityCalculateData*)data;
    RpTriangle              *triangles = ws->triangles;
    RwV3d                   *vtx       = ws->vertices;
    RpMaterialList          *matList;
    RwReal                  scaledArea;

    RWFUNCTION(RWSTRING("_rtLtMapWorldDensityCB"));
    RWASSERT(data);

    numTriangles = RpWorldSectorGetNumPolygons(ws);
    if (numTriangles == 0)
        return ws;

    RWASSERT(triangles);
    RWASSERT(vtx);

    matList = &(RpWorldSectorGetWorld (ws)->matList);

    /* Take into account existing density when calculating total area */
    scaledArea  = LtMapCalculateCumulateArea (vtx, triangles, numTriangles, matList, ws->matListWindowBase);

    cdata->area += scaledArea;
    cdata->numWS++;

    RWRETURN(ws);
}

/**
 * \ingroup rtltmap
 * \ref RtLtMapWorldCalculateDensity will generate a global density for a
 * world.
 *
 * The calculation is based on the assumption that the geometry is distributed
 * evenly across the world sectors.
 *
 * The returned value can then be passed to \ref RtLtMapLightMapsCreate.
 *
 * Although RtLtMapWorldCalculateDensity usually gives correct results, if any
 * density problems occur, scale down the value returned
 * by \ref RtLtMapWorldCalculateDensity until expected
 * results are achieved.
 *
 * The default lightmap size needs to be set before calling this function
 * (\ref RtLtMapLightMapSetDefaultSize).
 *
 * \param  world    A pointer to the \ref RpWorld
 *
 * \return The calculated density
 *
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapLightMapSetDefaultSize
 * \see RtLtMapAtomicCalculateDensity
 */
RwReal
RtLtMapWorldCalculateDensity(RpWorld *world)
{
    RwReal area;
    RwReal density = 1.0f;
    _rtdensityCalculateData data;

    RWAPIFUNCTION(RWSTRING("RtLtMapWorldCalculateDensity"));
    RWASSERT(world);

    data.area = 0.0f;
    data.numWS = 0;

    RpWorldForAllWorldSectors(world,_rtLtMapWorldDensityCB,(void*)(&data));

    rwSqrt(&area,data.area);
    if( area > 0.0f )
    {
        density = (RwReal)RtLtMapLightMapGetDefaultSize()/area * DENSITY_FUDGE_FACTOR;
    }

    RWRETURN(density);
}


/**
 * \ingroup rtltmap
 * \ref RtLtMapAtomicCalculateDensity will generate a global density for an
 * atomic.
 *
 * The returned value can then be passed to \ref RtLtMapLightMapsCreate.
 *
 * Although RtLtMapAtomicCalculateDensity usually gives correct results, if
 * density problems occur, scale down the value returned
 * by \ref RtLtMapAtomicCalculateDensity until expected
 * results are achieved.
 *
 * The default lightmap size needs to be set before calling this function
 * (\ref RtLtMapLightMapSetDefaultSize).
 *
 * \param  atomic    A pointer to the \ref RpAtomic
 *
 * \return The calculated density
 *
 * \see RtLtMapLightMapsCreate
 * \see RtLtMapLightMapSetDefaultSize
 * \see RtLtMapWorldCalculateDensity
 */
RwReal
RtLtMapAtomicCalculateDensity(RpAtomic *atomic)
{
    RpGeometry *geom;
    RwReal density = 1.0f;
    RwUInt32 numTriangles;
    RpMorphTarget *morphTarget;
    RpTriangle *triangles;
    RwV3d *vtx;
    RwReal area;
    RwReal cumulatedArea;

    RWAPIFUNCTION(RWSTRING("RtLtMapAtomicCalculateDensity"));
    RWASSERT(atomic);
    geom = RpAtomicGetGeometry(atomic);
    RWASSERT(geom);

    /* If vertex lighting is off, density is zero */
    if (!(RtLtMapAtomicGetFlags(atomic) & rtLTMAPOBJECTLIGHTMAP))
        RWRETURN (0.0f);

    numTriangles = RpGeometryGetNumTriangles(geom);
    if (numTriangles == 0)
        return density;

    morphTarget = RpGeometryGetMorphTarget(geom, 0);
    triangles   = RpGeometryGetTriangles  (geom);
    RWASSERT(morphTarget);
    RWASSERT(triangles);

    vtx = RpMorphTargetGetVertices(morphTarget);
    RWASSERT(vtx);

    cumulatedArea = LtMapCalculateCumulateArea (vtx, triangles, numTriangles, &(geom->matList), 0);

    rwSqrt(&area,cumulatedArea);

    if( area > 0.0f )
    {
        density = (RwReal)RtLtMapLightMapGetDefaultSize()/area * DENSITY_FUDGE_FACTOR;
    }

    RWRETURN(density);
}
